# RFC-007: Testes e Validação

**Status:** Rascunho  
**Autor:** Sistema de Desenvolvimento  
**Data:** Janeiro 2025  
**Versão:** 1.0  

## Resumo

Esta RFC define a estratégia completa de testes e validação para a ferramenta MCP Hotmart, garantindo qualidade, confiabilidade e funcionalidade correta em todos os cenários de uso, desde testes unitários até validação em produção.

## Motivação

A integração MCP + Hotmart + IA introduz complexidade em múltiplas camadas:

- **Processamento de Linguagem Natural:** Variações de entrada imprevisíveis
- **Integração com API Externa:** Falhas de rede, mudanças de API, rate limits
- **Contexto de Sessão:** Estado complexo e interdependências
- **Formatação de Resposta:** Adaptação cultural e personalização
- **Performance:** Tempos de resposta aceitáveis mesmo com múltiplas operações

## Especificação Técnica

### 1. Pirâmide de Testes

```typescript
interface TestStrategy {
  unitTests: UnitTestSuite;        // 70% - Testes rápidos, isolados
  integrationTests: IntegrationTestSuite; // 20% - Testes de integração
  e2eTests: E2ETestSuite;         // 10% - Testes ponta a ponta
  performanceTests: PerformanceTestSuite;
  securityTests: SecurityTestSuite;
}

// Estrutura dos testes unitários
interface UnitTestSuite {
  nlpProcessing: NLPTests;
  operationMapping: MappingTests;
  responseFormatting: FormattingTests;
  cacheLogic: CacheTests;
  contextManagement: ContextTests;
}
```

### 2. Testes de Processamento de Linguagem Natural

```typescript
describe('Processamento de Linguagem Natural', () => {
  const nlp = new NaturalLanguageProcessor();
  
  describe('Comandos de Vendas', () => {
    test('deve interpretar consulta básica', () => {
      const result = nlp.parseCommand("mostre as vendas do último mês");
      
      expect(result.resource).toBe('vendas');
      expect(result.action).toBe('consultar');
      expect(result.parameters.periodo).toBeDefined();
      expect(result.confidence).toBeGreaterThan(0.8);
    });
    
    test('deve extrair valores monetários', () => {
      const result = nlp.parseCommand("vendas acima de R$ 1.500,00");
      
      expect(result.parameters.valorMinimo).toBe(1500.00);
    });
    
    test('deve reconhecer períodos relativos', () => {
      const cases = [
        { input: "vendas de ontem", expected: getDateDaysAgo(1) },
        { input: "vendas da semana passada", expected: getWeekRange(-1) },
        { input: "vendas de janeiro", expected: getMonthRange(1) }
      ];
      
      cases.forEach(({ input, expected }) => {
        const result = nlp.parseCommand(input);
        expect(result.parameters.periodo).toEqual(expected);
      });
    });
  });
  
  describe('Comandos de Assinaturas', () => {
    test('deve interpretar cancelamento em lote', () => {
      const result = nlp.parseCommand("cancele todas as assinaturas em atraso");
      
      expect(result.resource).toBe('assinaturas');
      expect(result.action).toBe('cancelar');
      expect(result.parameters.criterio).toBe('em_atraso');
      expect(result.parameters.lote).toBe(true);
    });
    
    test('deve interpretar reativação específica', () => {
      const result = nlp.parseCommand("reative a assinatura do cliente joão@email.com");
      
      expect(result.resource).toBe('assinaturas');
      expect(result.action).toBe('reativar');
      expect(result.parameters.email).toBe('joão@email.com');
    });
  });
  
  describe('Tratamento de Ambiguidades', () => {
    test('deve detectar comando ambíguo', () => {
      const result = nlp.parseCommand("mostre os dados");
      
      expect(result.confidence).toBeLessThan(0.6);
      expect(result.needsClarification).toBe(true);
    });
    
    test('deve resolver referência contextual', () => {
      const context = {
        lastProduct: 'Curso de Marketing',
        lastDateRange: { start: '2024-01-01', end: '2024-01-31' }
      };
      
      const result = nlp.parseCommandWithContext("mostre mais detalhes", context);
      
      expect(result.parameters.produto).toBe('Curso de Marketing');
      expect(result.parameters.periodo).toEqual(context.lastDateRange);
    });
  });
});
```

### 3. Testes de Mapeamento de Operações

```typescript
describe('Mapeamento Inteligente de Operações', () => {
  const mapper = new OperationMapper();
  
  test('deve mapear para operação única', () => {
    const intention = {
      resource: 'vendas',
      action: 'consultar',
      parameters: { periodo: { start: '2024-01-01', end: '2024-01-31' } }
    };
    
    const mapped = mapper.mapToOperation(intention, mockContext);
    
    expect(mapped.nodeOperation).toBe('sales:getHistoricoVendas');
    expect(mapped.parameters).toMatchObject({
      startDate: '2024-01-01',
      endDate: '2024-01-31'
    });
  });
  
  test('deve otimizar múltiplas operações', () => {
    const intentions = [
      { resource: 'assinaturas', action: 'consultar', parameters: { status: 'ativa' } },
      { resource: 'assinaturas', action: 'consultar', parameters: { status: 'cancelada' } },
      { resource: 'assinaturas', action: 'consultar', parameters: { status: 'vencendo' } }
    ];
    
    const optimized = mapper.optimizeExecution(intentions);
    
    expect(optimized.batchedOperations).toHaveLength(1);
    expect(optimized.batchedOperations[0].operation).toBe('subscription:getAll');
    expect(optimized.postProcessing).toContain('filterByStatus');
  });
  
  test('deve validar permissões', () => {
    const operation = {
      nodeOperation: 'subscription:cancel',
      parameters: { subscriptionId: '123' }
    };
    
    const result = mapper.validatePermissions(operation, mockCredentials);
    
    expect(result.valid).toBe(true);
  });
  
  test('deve sugerir alternativas para operação não permitida', () => {
    const operation = {
      nodeOperation: 'subscription:cancelList',
      parameters: { criteria: 'all' }
    };
    
    const credentials = { permissions: ['subscription:read'] }; // Sem permissão de escrita
    
    const result = mapper.validatePermissions(operation, credentials);
    
    expect(result.valid).toBe(false);
    expect(result.suggested).toBeDefined();
    expect(result.suggested[0].operation).toBe('subscription:getAll');
  });
});
```

### 4. Testes de Integração com API Hotmart

```typescript
describe('Integração com API Hotmart', () => {
  let mockHotmartApi: MockHotmartApi;
  
  beforeEach(() => {
    mockHotmartApi = new MockHotmartApi();
  });
  
  test('deve tratar rate limit graciosamente', async () => {
    mockHotmartApi.setRateLimit(true);
    
    const request = new HotmartRequest('sales:getHistoricoVendas', mockCredentials);
    const result = await request.execute();
    
    expect(result.success).toBe(false);
    expect(result.error.type).toBe('RATE_LIMIT_EXCEEDED');
    expect(result.retryAfter).toBeDefined();
  });
  
  test('deve implementar retry automático', async () => {
    mockHotmartApi.setFailureRate(0.3); // 30% de falha
    
    const request = new HotmartRequest('products:getAll', mockCredentials);
    const result = await request.executeWithRetry({ maxRetries: 3 });
    
    expect(mockHotmartApi.getCallCount()).toBeGreaterThan(1);
    expect(result.success).toBe(true);
  });
  
  test('deve manter autenticação OAuth2', async () => {
    mockHotmartApi.setTokenExpiration(Date.now() + 1000); // Expira em 1s
    
    const request = new HotmartRequest('sales:getHistoricoVendas', mockCredentials);
    
    // Primeira chamada
    await request.execute();
    
    // Aguardar expiração do token
    await new Promise(resolve => setTimeout(resolve, 1100));
    
    // Segunda chamada deve renovar token automaticamente
    const result = await request.execute();
    
    expect(result.success).toBe(true);
    expect(mockHotmartApi.getTokenRenewalCount()).toBe(1);
  });
  
  test('deve transformar dados da API corretamente', async () => {
    const mockApiResponse = {
      items: [
        { transaction: 'T123', value: 15000, currency: 'BRL', date: '2024-01-15' }
      ]
    };
    
    mockHotmartApi.setMockResponse('sales:getHistoricoVendas', mockApiResponse);
    
    const request = new HotmartRequest('sales:getHistoricoVendas', mockCredentials);
    const result = await request.execute();
    
    expect(result.data).toMatchObject({
      vendas: [
        {
          transacao: 'T123',
          valor: 150.00, // Conversão de centavos
          moeda: 'BRL',
          data: '15/01/2024' // Formatação brasileira
        }
      ]
    });
  });
});
```

### 5. Testes de Performance

```typescript
describe('Performance', () => {
  test('deve responder em menos de 3 segundos para operações simples', async () => {
    const startTime = Date.now();
    
    const result = await executeMCPCommand("vendas do último mês");
    
    const executionTime = Date.now() - startTime;
    expect(executionTime).toBeLessThan(3000);
    expect(result.success).toBe(true);
  });
  
  test('deve usar cache eficientemente', async () => {
    const cache = new IntelligentCache();
    
    // Primeira execução
    const result1 = await executeCachedOperation('sales:getHistoricoVendas', cache);
    
    // Segunda execução (deve usar cache)
    const startTime = Date.now();
    const result2 = await executeCachedOperation('sales:getHistoricoVendas', cache);
    const cacheTime = Date.now() - startTime;
    
    expect(cacheTime).toBeLessThan(100); // Muito rápido por usar cache
    expect(result1.data).toEqual(result2.data);
  });
  
  test('deve processar operações em lote eficientemente', async () => {
    const intentions = generateMultipleIntentions(10);
    
    const startTime = Date.now();
    const results = await processIntentionsBatch(intentions);
    const batchTime = Date.now() - startTime;
    
    // Batch deve ser mais rápido que execução individual
    const individualTime = await processIntentionsIndividually(intentions);
    
    expect(batchTime).toBeLessThan(individualTime * 0.7); // 30% mais rápido
    expect(results).toHaveLength(10);
  });
  
  test('deve manter performance sob carga', async () => {
    const concurrentRequests = 50;
    const promises = Array.from({ length: concurrentRequests }, (_, i) =>
      executeMCPCommand(`vendas do produto ${i}`)
    );
    
    const startTime = Date.now();
    const results = await Promise.all(promises);
    const totalTime = Date.now() - startTime;
    
    expect(results.every(r => r.success)).toBe(true);
    expect(totalTime).toBeLessThan(10000); // 10 segundos para 50 requests
  });
});
```

### 6. Testes End-to-End

```typescript
describe('Cenários End-to-End', () => {
  test('jornada completa: análise de vendas', async () => {
    // 1. Comando inicial
    let result = await executeMCPCommand("analise minhas vendas de dezembro");
    
    expect(result.success).toBe(true);
    expect(result.data.resumo).toContain('dezembro');
    expect(result.suggestions).toHaveLength(3);
    
    // 2. Comando de follow-up
    result = await executeMCPCommand("compare com novembro");
    
    expect(result.success).toBe(true);
    expect(result.data.comparacao).toBeDefined();
    expect(result.data.tendencia).toMatch(/(aumentou|diminuiu|manteve)/);
    
    // 3. Comando de ação
    result = await executeMCPCommand("mostre o produto que mais vendeu");
    
    expect(result.success).toBe(true);
    expect(result.data.produto).toBeDefined();
    expect(result.data.metricas).toMatchObject({
      vendas: expect.any(Number),
      receita: expect.any(Number)
    });
  });
  
  test('jornada completa: gestão de assinaturas', async () => {
    // 1. Consulta situação geral
    let result = await executeMCPCommand("como estão minhas assinaturas?");
    
    expect(result.success).toBe(true);
    expect(result.data.resumo).toBeDefined();
    expect(result.actions).toContain(expect.objectContaining({
      priority: 'alta'
    }));
    
    // 2. Identificar problemas
    result = await executeMCPCommand("quais assinaturas estão com problema?");
    
    expect(result.success).toBe(true);
    expect(result.data.assinaturas_problema).toBeDefined();
    
    // 3. Tomar ação
    result = await executeMCPCommand("envie lembretes para as assinaturas em atraso");
    
    expect(result.success).toBe(true);
    expect(result.data.lembretes_enviados).toBeGreaterThan(0);
  });
  
  test('tratamento de erro gracioso', async () => {
    // Simular API da Hotmart down
    mockHotmartApi.setDown(true);
    
    const result = await executeMCPCommand("vendas de hoje");
    
    expect(result.success).toBe(false);
    expect(result.error.message).toContain('API da Hotmart temporariamente indisponível');
    expect(result.suggestions).toContain(expect.objectContaining({
      action: expect.stringContaining('tentar novamente')
    }));
  });
});
```

### 7. Testes de Segurança

```typescript
describe('Segurança', () => {
  test('deve validar credenciais OAuth2', async () => {
    const invalidCredentials = { ...mockCredentials, accessToken: 'invalid' };
    
    const result = await executeMCPCommandWithCredentials(
      "vendas do último mês", 
      invalidCredentials
    );
    
    expect(result.success).toBe(false);
    expect(result.error.type).toBe('AUTHENTICATION_FAILED');
  });
  
  test('deve sanitizar entrada do usuário', async () => {
    const maliciousCommand = "vendas'); DROP TABLE sales; --";
    
    const result = await executeMCPCommand(maliciousCommand);
    
    // Deve processar como comando normal sem injeção
    expect(result.success).toBe(false);
    expect(result.error.type).toBe('COMMAND_NOT_UNDERSTOOD');
  });
  
  test('deve implementar rate limiting por usuário', async () => {
    const userId = 'test-user';
    const requests = Array.from({ length: 100 }, () =>
      executeMCPCommandAsUser("vendas", userId)
    );
    
    const results = await Promise.all(requests);
    const rateLimitedCount = results.filter(r => 
      r.error?.type === 'RATE_LIMIT_EXCEEDED'
    ).length;
    
    expect(rateLimitedCount).toBeGreaterThan(50); // Pelo menos metade bloqueada
  });
  
  test('não deve vazar informações sensíveis em logs', async () => {
    const logger = new TestLogger();
    
    await executeMCPCommandWithLogger(
      "vendas do cliente cliente@secreto.com",
      logger
    );
    
    const logs = logger.getLogs();
    const hasEmail = logs.some(log => log.message.includes('cliente@secreto.com'));
    
    expect(hasEmail).toBe(false); // Email deve ser mascarado nos logs
  });
});
```

### 8. Testes de Contexto e Memória

```typescript
describe('Contexto e Memória', () => {
  test('deve manter contexto entre comandos', async () => {
    const sessionId = 'test-session';
    
    // Comando 1
    let result = await executeMCPCommandInSession(
      "vendas do produto Curso de Marketing",
      sessionId
    );
    
    expect(result.success).toBe(true);
    
    // Comando 2 - referência contextual
    result = await executeMCPCommandInSession(
      "compare com o mês anterior",
      sessionId
    );
    
    expect(result.success).toBe(true);
    expect(result.data.comparacao).toBeDefined();
    expect(result.data.produto).toBe('Curso de Marketing'); // Manteve contexto
  });
  
  test('deve limpar contexto expirado', async () => {
    const contextManager = new ContextManager();
    
    // Criar contexto
    const sessionId = await contextManager.createSession();
    
    // Simular expiração
    contextManager.setSessionExpiry(sessionId, Date.now() - 1000);
    
    // Tentar usar contexto expirado
    const context = await contextManager.getSession(sessionId);
    
    expect(context).toBeNull();
  });
  
  test('deve resolver referências pronominais', () => {
    const resolver = new ReferenceResolver();
    const context = {
      lastProduct: 'Curso de Marketing',
      lastResults: [{ id: 1, name: 'Produto A' }]
    };
    
    const resolved = resolver.resolvePronouns("mostre mais detalhes disso", context);
    
    expect(resolved).toContain('Produto A');
  });
});
```

### 9. Testes de Formatação de Resposta

```typescript
describe('Formatação de Resposta', () => {
  test('deve formatar valores monetários corretamente', () => {
    const formatter = new BrazilianFormatter();
    
    expect(formatter.formatCurrency(15000)).toBe('R$ 150,00');
    expect(formatter.formatCurrency(150000)).toBe('R$ 1.500,00');
  });
  
  test('deve adaptar tom para diferentes audiências', () => {
    const adapter = new ToneAdapter();
    
    const technical = "Taxa de conversão de 4,2% com churn rate de 8,5%";
    
    const beginner = adapter.adaptTone(technical, { audience: 'iniciante' });
    expect(beginner).not.toContain('churn rate');
    expect(beginner).toContain('taxa de cancelamento');
    
    const advanced = adapter.adaptTone(technical, { audience: 'avançado' });
    expect(advanced).toContain('churn rate');
  });
  
  test('deve gerar insights relevantes', () => {
    const generator = new InsightGenerator();
    const mockData = [
      { produto: 'A', vendas: 100, receita: 10000 },
      { produto: 'B', vendas: 20, receita: 8000 }
    ];
    
    const insights = generator.generateInsights(mockData, { verbosity: 'normal' });
    
    expect(insights).toHaveLength(3);
    expect(insights[0]).toMatch(/80%.*20%/); // Regra 80/20
  });
});
```

### 10. Configuração de Testes

```typescript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.+(ts|tsx|js)',
    '**/*.(test|spec).+(ts|tsx|js)'
  ],
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest'
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/test-helpers/**/*'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts']
};

// tests/setup.ts
import { MockHotmartApi } from './mocks/MockHotmartApi';
import { TestLogger } from './mocks/TestLogger';

global.mockHotmartApi = new MockHotmartApi();
global.testLogger = new TestLogger();

// Mock das credenciais para testes
global.mockCredentials = {
  clientId: 'test-client-id',
  clientSecret: 'test-client-secret',
  accessToken: 'test-access-token',
  refreshToken: 'test-refresh-token'
};
```

## Estratégia de Validação em Produção

### 1. Canary Release
```typescript
interface CanaryConfig {
  percentage: number; // % de usuários que recebem nova versão
  metrics: string[]; // Métricas a monitorar
  rollbackTriggers: RollbackTrigger[];
}

class CanaryDeployment {
  async deployCanary(version: string, config: CanaryConfig): Promise<boolean> {
    // Implementar deploy gradual
    // Monitorar métricas
    // Rollback automático se necessário
  }
}
```

### 2. Feature Flags
```typescript
class FeatureFlags {
  isEnabled(feature: string, userId: string): boolean {
    // Implementar feature flags para rollout controlado
  }
}
```

### 3. Monitoramento Contínuo
```typescript
class ProductionValidator {
  async runHealthChecks(): Promise<HealthStatus> {
    // Verificações automáticas em produção
  }
  
  async runSyntheticTests(): Promise<TestResults> {
    // Testes sintéticos simulando usuários reais
  }
}
```

## Arquivos de Teste

```
tests/
├── unit/
│   ├── nlp/
│   ├── mapping/
│   ├── formatting/
│   └── context/
├── integration/
│   ├── api/
│   └── cache/
├── e2e/
│   └── scenarios/
├── performance/
│   └── load/
├── security/
│   └── penetration/
├── mocks/
│   ├── MockHotmartApi.ts
│   ├── TestLogger.ts
│   └── MockCredentials.ts
└── fixtures/
    ├── commands.json
    ├── responses.json
    └── test-data.json
```

## Critérios de Aceitação

### Cobertura de Testes
- [ ] Cobertura de código > 80%
- [ ] Cobertura de testes unitários > 90%
- [ ] Todos os cenários críticos cobertos

### Performance
- [ ] Todos os testes de performance passando
- [ ] Tempo de execução da suíte < 10 minutos
- [ ] Testes de carga validados

### Qualidade
- [ ] Taxa de falsos positivos < 5%
- [ ] Todos os testes de segurança passando
- [ ] Validação de entrada completa

## Dependências

- RFC-001 a RFC-006 (todas as RFCs anteriores implementadas)
- Ambiente de testes configurado
- Mocks da API Hotmart
- Ferramentas de teste instaladas

## Métricas de Sucesso

- **Cobertura de Testes:** > 80%
- **Tempo de Execução:** < 10 min para suíte completa
- **Taxa de Falha:** < 1% em produção
- **Detecção de Regressões:** > 95%
- **Confiabilidade:** > 99.5% uptime