# RFC-006: Sistema de Monitoramento e Analytics

**Status:** Rascunho  
**Autor:** Sistema de Desenvolvimento  
**Data:** Janeiro 2025  
**Versão:** 1.0  

## Resumo

Esta RFC define o sistema de monitoramento e analytics que coleta métricas de uso, performance e eficácia da ferramenta MCP Hotmart, fornecendo insights para otimização contínua e detecção proativa de problemas.

## Motivação

Para garantir excelência na experiência do usuário e evolução constante da ferramenta, precisamos:

- **Monitorar Performance:** Identificar gargalos e otimizar tempo de resposta
- **Medir Eficácia:** Entender quais funcionalidades são mais utilizadas e úteis
- **Detectar Problemas:** Alertas automáticos para falhas da API ou degradação
- **Análise de Uso:** Insights para priorizar desenvolvimentos futuros
- **Qualidade de Resposta:** Medir precisão das interpretações de linguagem natural

## Especificação Técnica

### 1. Sistema de Métricas Core

```typescript
interface Analytics {
  trackCommandUsage(command: string, success: boolean, executionTime: number): void;
  trackApiCall(endpoint: string, responseTime: number, statusCode: number): void;
  trackUserIntent(originalCommand: string, parsedIntent: ParsedIntention, confidence: number): void;
  trackCacheHit(operation: string, hit: boolean): void;
  trackError(error: Error, context: ErrorContext): void;
}

interface Metrics {
  // Métricas de uso
  commandFrequency: Map<string, number>;
  totalCommands: number;
  uniqueUsers: Set<string>;
  sessionDuration: number[];
  
  // Métricas de performance
  averageResponseTime: number;
  apiCallLatency: Map<string, number[]>;
  cacheHitRate: number;
  errorRate: number;
  
  // Métricas de qualidade
  nlpConfidenceScores: number[];
  userSatisfactionRatings: number[];
  commandSuccessRate: number;
}

interface HealthMetrics {
  systemHealth: 'saudavel' | 'degradado' | 'critico';
  apiAvailability: Map<string, number>; // endpoint -> uptime %
  lastUpdateTime: Date;
  alerts: Alert[];
}
```

### 2. Coletores de Dados

```typescript
class PerformanceCollector {
  private metrics: Metrics;
  
  startTimer(operationId: string): string {
    const timerId = `${operationId}_${Date.now()}`;
    this.timers.set(timerId, Date.now());
    return timerId;
  }
  
  endTimer(timerId: string, operation: string): number {
    const startTime = this.timers.get(timerId);
    if (!startTime) return 0;
    
    const duration = Date.now() - startTime;
    this.recordExecutionTime(operation, duration);
    this.timers.delete(timerId);
    
    return duration;
  }
  
  recordExecutionTime(operation: string, duration: number): void {
    if (!this.executionTimes.has(operation)) {
      this.executionTimes.set(operation, []);
    }
    
    const times = this.executionTimes.get(operation)!;
    times.push(duration);
    
    // Manter apenas os últimos 1000 registros
    if (times.length > 1000) {
      times.shift();
    }
    
    // Calcular estatísticas
    this.updatePerformanceStats(operation, times);
  }
  
  private updatePerformanceStats(operation: string, times: number[]): void {
    const avg = times.reduce((a, b) => a + b, 0) / times.length;
    const p95 = this.calculatePercentile(times, 95);
    const p99 = this.calculatePercentile(times, 99);
    
    this.performanceStats.set(operation, {
      average: avg,
      median: this.calculatePercentile(times, 50),
      p95,
      p99,
      samples: times.length
    });
    
    // Alertar se performance degradou
    if (p95 > this.getThreshold(operation)) {
      this.triggerPerformanceAlert(operation, p95);
    }
  }
}
```

### 3. Monitoramento de API External

```typescript
class ApiHealthMonitor {
  private endpointStatus: Map<string, EndpointHealth> = new Map();
  
  async checkEndpointHealth(endpoint: string): Promise<EndpointHealth> {
    const startTime = Date.now();
    
    try {
      const response = await this.makeHealthCheckRequest(endpoint);
      const responseTime = Date.now() - startTime;
      
      const health: EndpointHealth = {
        endpoint,
        status: response.status >= 200 && response.status < 300 ? 'up' : 'down',
        responseTime,
        lastCheck: new Date(),
        errorCount: 0
      };
      
      this.endpointStatus.set(endpoint, health);
      return health;
      
    } catch (error) {
      const health: EndpointHealth = {
        endpoint,
        status: 'down',
        responseTime: Date.now() - startTime,
        lastCheck: new Date(),
        errorCount: (this.endpointStatus.get(endpoint)?.errorCount || 0) + 1,
        lastError: error.message
      };
      
      this.endpointStatus.set(endpoint, health);
      
      // Alertar após 3 falhas consecutivas
      if (health.errorCount >= 3) {
        this.triggerApiDownAlert(endpoint, health);
      }
      
      return health;
    }
  }
  
  startPeriodicHealthCheck(intervalMs: number = 300000): void { // 5 minutos
    setInterval(async () => {
      const hotmartEndpoints = [
        'https://developers.hotmart.com/payments/api/v1/sales/history',
        'https://developers.hotmart.com/payments/api/v1/subscriptions',
        'https://developers.hotmart.com/payments/api/v1/products'
      ];
      
      for (const endpoint of hotmartEndpoints) {
        await this.checkEndpointHealth(endpoint);
      }
    }, intervalMs);
  }
}
```

### 4. Analytics de Uso de Comandos

```typescript
class UsageAnalytics {
  private commandPatterns: Map<string, CommandPattern> = new Map();
  
  analyzeCommandUsage(commands: HistoryEntry[]): UsageInsights {
    const insights: UsageInsights = {
      mostUsedCommands: this.getMostUsedCommands(commands),
      userJourney: this.analyzeUserJourney(commands),
      timePatterns: this.analyzeTimePatterns(commands),
      successPatterns: this.analyzeSuccessPatterns(commands),
      errorPatterns: this.analyzeErrorPatterns(commands)
    };
    
    return insights;
  }
  
  private getMostUsedCommands(commands: HistoryEntry[]): CommandFrequency[] {
    const frequency = new Map<string, number>();
    
    commands.forEach(cmd => {
      const category = this.categorizeCommand(cmd.parsedIntention);
      frequency.set(category, (frequency.get(category) || 0) + 1);
    });
    
    return Array.from(frequency.entries())
      .map(([command, count]) => ({ command, count, percentage: count / commands.length * 100 }))
      .sort((a, b) => b.count - a.count);
  }
  
  private analyzeUserJourney(commands: HistoryEntry[]): JourneyInsight[] {
    const journeys: JourneyInsight[] = [];
    
    // Identificar sequências comuns de comandos
    for (let i = 0; i < commands.length - 1; i++) {
      const current = this.categorizeCommand(commands[i].parsedIntention);
      const next = this.categorizeCommand(commands[i + 1].parsedIntention);
      
      const journey = `${current} → ${next}`;
      const existing = journeys.find(j => j.sequence === journey);
      
      if (existing) {
        existing.frequency++;
      } else {
        journeys.push({ sequence: journey, frequency: 1 });
      }
    }
    
    return journeys.sort((a, b) => b.frequency - a.frequency);
  }
  
  private categorizeCommand(intention: ParsedIntention): string {
    return `${intention.resource}:${intention.action}`;
  }
}
```

### 5. Sistema de Alertas Inteligentes

```typescript
interface Alert {
  id: string;
  type: 'performance' | 'error' | 'api_down' | 'usage' | 'quality';
  severity: 'info' | 'warning' | 'critical';
  message: string;
  timestamp: Date;
  resolved: boolean;
  metadata: Record<string, any>;
}

class AlertSystem {
  private alerts: Alert[] = [];
  private rules: AlertRule[] = [];
  
  addRule(rule: AlertRule): void {
    this.rules.push(rule);
  }
  
  evaluateRules(metrics: Metrics): Alert[] {
    const newAlerts: Alert[] = [];
    
    for (const rule of this.rules) {
      const result = rule.evaluate(metrics);
      if (result.triggered) {
        const alert: Alert = {
          id: this.generateAlertId(),
          type: rule.type,
          severity: rule.severity,
          message: result.message,
          timestamp: new Date(),
          resolved: false,
          metadata: result.metadata
        };
        
        newAlerts.push(alert);
        this.alerts.push(alert);
      }
    }
    
    return newAlerts;
  }
  
  // Regras pré-definidas
  setupDefaultRules(): void {
    // Regra: Performance degradada
    this.addRule({
      type: 'performance',
      severity: 'warning',
      evaluate: (metrics) => ({
        triggered: metrics.averageResponseTime > 5000, // 5s
        message: `Tempo de resposta médio alto: ${metrics.averageResponseTime}ms`,
        metadata: { threshold: 5000, actual: metrics.averageResponseTime }
      })
    });
    
    // Regra: Taxa de erro alta
    this.addRule({
      type: 'error',
      severity: 'critical',
      evaluate: (metrics) => ({
        triggered: metrics.errorRate > 0.05, // 5%
        message: `Taxa de erro alta: ${(metrics.errorRate * 100).toFixed(1)}%`,
        metadata: { threshold: 0.05, actual: metrics.errorRate }
      })
    });
    
    // Regra: Confiança do NLP baixa
    this.addRule({
      type: 'quality',
      severity: 'warning',
      evaluate: (metrics) => {
        const avgConfidence = metrics.nlpConfidenceScores.reduce((a, b) => a + b, 0) / 
                            metrics.nlpConfidenceScores.length;
        return {
          triggered: avgConfidence < 0.7,
          message: `Confiança média do NLP baixa: ${avgConfidence.toFixed(2)}`,
          metadata: { threshold: 0.7, actual: avgConfidence }
        };
      }
    });
  }
}
```

### 6. Dashboard de Saúde do Sistema

```typescript
class HealthDashboard {
  generateHealthReport(): HealthReport {
    const performanceMetrics = this.getPerformanceMetrics();
    const apiHealths = this.getApiHealthStatus();
    const usageStats = this.getUsageStatistics();
    const qualityMetrics = this.getQualityMetrics();
    
    return {
      systemStatus: this.calculateOverallStatus(performanceMetrics, apiHealths),
      performance: performanceMetrics,
      apiHealth: apiHealths,
      usage: usageStats,
      quality: qualityMetrics,
      alerts: this.getActiveAlerts(),
      recommendations: this.generateRecommendations(),
      lastUpdated: new Date()
    };
  }
  
  private calculateOverallStatus(
    performance: PerformanceMetrics,
    apiHealth: ApiHealthStatus[]
  ): SystemStatus {
    
    // Sistema crítico se alguma API estiver down
    if (apiHealth.some(api => api.status === 'down')) {
      return 'critico';
    }
    
    // Sistema degradado se performance ruim ou APIs lentas
    if (performance.averageResponseTime > 5000 || 
        apiHealth.some(api => api.responseTime > 10000)) {
      return 'degradado';
    }
    
    return 'saudavel';
  }
  
  generateRecommendations(): Recommendation[] {
    const recommendations: Recommendation[] = [];
    
    // Analisar padrões e sugerir otimizações
    const metrics = this.getMetrics();
    
    if (metrics.cacheHitRate < 0.5) {
      recommendations.push({
        type: 'performance',
        priority: 'alta',
        title: 'Melhorar taxa de cache',
        description: 'Taxa de cache atual é baixa ('+metrics.cacheHitRate*100+'%). Considere aumentar TTL para operações de leitura.',
        action: 'Revisar configurações de cache nas operações mais utilizadas'
      });
    }
    
    if (this.hasFrequentErrorPattern()) {
      recommendations.push({
        type: 'reliability',
        priority: 'alta',
        title: 'Padrão de erros recorrentes',
        description: 'Detectamos erros recorrentes em operações específicas.',
        action: 'Implementar retry automático e melhor tratamento de erro'
      });
    }
    
    return recommendations;
  }
}
```

### 7. Métricas de Qualidade de NLP

```typescript
class NLPQualityMetrics {
  trackIntentClassification(
    originalCommand: string,
    predictedIntent: ParsedIntention,
    actualIntent?: ParsedIntention, // feedback do usuário
    confidence: number
  ): void {
    
    const record: NLPRecord = {
      command: originalCommand,
      predicted: predictedIntent,
      actual: actualIntent,
      confidence,
      timestamp: new Date(),
      correct: actualIntent ? this.compareIntents(predictedIntent, actualIntent) : undefined
    };
    
    this.nlpRecords.push(record);
    this.updateQualityMetrics();
  }
  
  calculateNLPAccuracy(): NLPAccuracyMetrics {
    const recordsWithFeedback = this.nlpRecords.filter(r => r.actual && r.correct !== undefined);
    
    if (recordsWithFeedback.length === 0) {
      return { accuracy: 0, samples: 0, needsMoreData: true };
    }
    
    const correct = recordsWithFeedback.filter(r => r.correct).length;
    const accuracy = correct / recordsWithFeedback.length;
    
    return {
      accuracy,
      samples: recordsWithFeedback.length,
      needsMoreData: recordsWithFeedback.length < 100,
      accuracyByConfidence: this.calculateAccuracyByConfidenceRange(recordsWithFeedback),
      commonMisclassifications: this.identifyCommonMisclassifications(recordsWithFeedback)
    };
  }
  
  private identifyCommonMisclassifications(records: NLPRecord[]): Misclassification[] {
    const misclassifications = records
      .filter(r => !r.correct)
      .reduce((acc, record) => {
        const key = `${record.predicted.resource}:${record.predicted.action} → ${record.actual!.resource}:${record.actual!.action}`;
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);
    
    return Object.entries(misclassifications)
      .map(([pattern, count]) => ({ pattern, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5); // Top 5 misclassifications
  }
}
```

## Sistema de Logging Estruturado

```typescript
interface LogEntry {
  timestamp: Date;
  level: 'debug' | 'info' | 'warn' | 'error';
  category: 'nlp' | 'api' | 'cache' | 'auth' | 'performance';
  message: string;
  metadata: Record<string, any>;
  sessionId?: string;
  userId?: string;
}

class StructuredLogger {
  private logs: LogEntry[] = [];
  
  logNLPProcessing(command: string, result: ParsedIntention, confidence: number): void {
    this.log('info', 'nlp', 'Command processed', {
      originalCommand: command,
      parsedResource: result.resource,
      parsedAction: result.action,
      confidence,
      processingTime: Date.now()
    });
  }
  
  logApiCall(endpoint: string, responseTime: number, statusCode: number, error?: string): void {
    this.log(
      statusCode >= 400 ? 'error' : 'info',
      'api',
      `API call to ${endpoint}`,
      {
        endpoint,
        responseTime,
        statusCode,
        error,
        success: statusCode < 400
      }
    );
  }
  
  logCacheOperation(operation: string, hit: boolean, key: string): void {
    this.log('debug', 'cache', `Cache ${hit ? 'hit' : 'miss'}`, {
      operation,
      hit,
      key: this.hashKey(key) // Hash da chave para privacidade
    });
  }
  
  exportLogs(startDate: Date, endDate: Date): LogEntry[] {
    return this.logs.filter(log => 
      log.timestamp >= startDate && 
      log.timestamp <= endDate
    );
  }
}
```

## Arquivos Impactados

- `nodes/Hotmart/v1/monitoring/` - Novo diretório
  - `Analytics.ts`
  - `PerformanceCollector.ts`
  - `ApiHealthMonitor.ts`
  - `UsageAnalytics.ts`
  - `AlertSystem.ts`
  - `HealthDashboard.ts`
  - `NLPQualityMetrics.ts`
  - `StructuredLogger.ts`
- `nodes/Hotmart/v1/HotmartV1.node.ts` - Integração com monitoramento

## Métricas Chave a Monitorar

### Performance
- Tempo de resposta médio por operação
- P95 e P99 de latência
- Taxa de cache hit/miss
- Uso de memória e CPU

### Qualidade
- Precisão do NLP (% de interpretações corretas)
- Confiança média das classificações
- Taxa de comandos não compreendidos
- Satisfação do usuário (ratings)

### Confiabilidade
- Taxa de erro geral
- Uptime das APIs da Hotmart
- Taxa de falsos positivos em alertas
- Tempo de recuperação de falhas

### Uso
- Comandos mais utilizados
- Jornadas de usuário comuns
- Sessões por usuário
- Funcionalidades menos utilizadas

## Compatibilidade

- ✅ **Privacy:** Logs anonimizados e seguros
- ✅ **Performance:** Coleta assíncrona sem impacto
- ✅ **Storage:** Rotação automática de logs antigos

## Critérios de Aceitação

- [ ] Coleta de métricas sem impacto na performance
- [ ] Sistema de alertas com regras configuráveis
- [ ] Dashboard de saúde atualizado em tempo real
- [ ] Logs estruturados para análise posterior
- [ ] Taxa de precisão do NLP monitorada
- [ ] Recomendações automáticas de otimização

## Dependências

- RFC-001 a RFC-005 (todas as RFCs anteriores)
- Sistema de logging do n8n
- Armazenamento para métricas históricas

## Próximos Passos

Após implementação desta RFC:
1. RFC-007: Testes e Validação (final)

## Alertas Críticos Definidos

### 1. Performance
- Tempo de resposta > 5s (Warning)
- Tempo de resposta > 10s (Critical)
- Cache hit rate < 30% (Warning)

### 2. API Externa
- Hotmart API down por > 5min (Critical)
- Rate limit atingido > 3x/dia (Warning)
- Erro de autenticação OAuth (Critical)

### 3. Qualidade
- Confiança NLP média < 70% (Warning)
- Taxa de comandos não reconhecidos > 20% (Warning)
- Satisfação usuário < 4.0/5.0 (Warning)

## Métricas de Sucesso

- **Uptime:** > 99.5%
- **Tempo de Resposta P95:** < 3s
- **Taxa de Cache Hit:** > 60%
- **Precisão NLP:** > 90%
- **MTTR (Mean Time to Recovery):** < 15 minutos