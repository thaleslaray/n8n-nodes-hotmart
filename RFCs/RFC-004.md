# RFC-004: Sistema de Contexto e Memória

**Status:** Rascunho  
**Autor:** Sistema de Desenvolvimento  
**Data:** Janeiro 2025  
**Versão:** 1.0  

## Resumo

Esta RFC define o sistema de contexto e memória que permite conversas fluidas e naturais com a ferramenta Hotmart, mantendo histórico de comandos, preferências do usuário e contexto de sessão para melhorar a experiência de uso.

## Motivação

Para interações naturais via IA, o sistema precisa "lembrar":

- **Contexto de Conversa:** "Mostre mais detalhes" → referente à última consulta
- **Preferências:** "Sempre mostrar em reais" → aplicar formatação padrão
- **Histórico:** "Igual ao mês passado" → usar mesmos parâmetros da consulta anterior
- **Estado:** "Continue de onde parou" → retomar operações interrompidas

## Especificação Técnica

### 1. Estrutura de Contexto de Sessão

```typescript
interface SessionContext {
  sessionId: string;
  userId: string;
  startTime: Date;
  lastActivity: Date;
  
  // Histórico de comandos
  commandHistory: HistoryEntry[];
  
  // Estado atual da conversa
  currentContext: ConversationContext;
  
  // Preferências do usuário
  userPreferences: UserPreferences;
  
  // Cache de resultados
  resultCache: Map<string, CachedResult>;
  
  // Estado de operações em andamento
  pendingOperations: PendingOperation[];
}

interface HistoryEntry {
  timestamp: Date;
  command: string;
  parsedIntention: ParsedIntention;
  executedOperations: string[];
  results: any;
  success: boolean;
  executionTime: number;
}

interface ConversationContext {
  lastProduct?: string;
  lastDateRange?: DateRange;
  activeFilters: Record<string, any>;
  lastResults: any[];
  referencePoints: Map<string, any>; // "isso", "aquele produto", etc.
}
```

### 2. Sistema de Resolução de Referências

```typescript
class ReferenceResolver {
  resolvePronouns(input: string, context: ConversationContext): string {
    let resolved = input;
    
    // Resolver pronomes demonstrativos
    resolved = resolved.replace(/\b(isso|esta|esta)\b/gi, () => {
      return context.referencePoints.get('last_item') || 'isso';
    });
    
    // Resolver referências temporais relativas
    resolved = resolved.replace(/\b(mesmo período|igual)\b/gi, () => {
      if (context.lastDateRange) {
        return this.formatDateRange(context.lastDateRange);
      }
      return 'mesmo período';
    });
    
    // Resolver referências de produto
    resolved = resolved.replace(/\b(mesmo produto|aquele produto)\b/gi, () => {
      return context.lastProduct || 'produto anterior';
    });
    
    return resolved;
  }
  
  extractNewReferences(results: any[], intention: ParsedIntention): Map<string, any> {
    const references = new Map();
    
    // Se resultado tem um item principal, marcar como "isso"
    if (results.length === 1) {
      references.set('last_item', results[0]);
    }
    
    // Se consulta foi sobre produto específico, guardar referência
    if (intention.parameters.productId) {
      references.set('last_product', intention.parameters.productId);
    }
    
    // Se consulta teve range de datas, guardar
    if (intention.parameters.dateRange) {
      references.set('last_date_range', intention.parameters.dateRange);
    }
    
    return references;
  }
}
```

### 3. Sistema de Preferências do Usuário

```typescript
interface UserPreferences {
  // Formatação
  currency: 'BRL' | 'USD' | 'EUR';
  dateFormat: 'DD/MM/YYYY' | 'MM/DD/YYYY' | 'YYYY-MM-DD';
  numberFormat: 'BR' | 'US'; // 1.000,00 vs 1,000.00
  
  // Comportamento
  defaultPeriod: 'last_month' | 'current_month' | 'last_7_days';
  verbosity: 'concise' | 'detailed' | 'verbose';
  autoConfirm: boolean; // Para operações destrutivas
  
  // Filtros padrão
  defaultFilters: Record<string, any>;
  
  // Produtos favoritos
  favoriteProducts: string[];
  
  // Notificações
  notifications: {
    lowSales: boolean;
    subscriptionIssues: boolean;
    newProducts: boolean;
  };
}

class PreferenceManager {
  applyPreferences(data: any[], preferences: UserPreferences): any[] {
    // Aplicar formatação de moeda
    if (preferences.currency === 'BRL') {
      data = this.formatCurrencyToBRL(data);
    }
    
    // Aplicar formato de data
    data = this.formatDates(data, preferences.dateFormat);
    
    // Aplicar nível de verbosidade
    if (preferences.verbosity === 'concise') {
      data = this.summarizeData(data);
    }
    
    return data;
  }
  
  updatePreferencesFromCommand(command: string, preferences: UserPreferences): UserPreferences {
    // Aprender preferências implícitas
    if (command.includes('resumo') || command.includes('sumário')) {
      preferences.verbosity = 'concise';
    }
    
    if (command.includes('detalhe') || command.includes('completo')) {
      preferences.verbosity = 'detailed';
    }
    
    return preferences;
  }
}
```

### 4. Cache Inteligente de Resultados

```typescript
interface CachedResult {
  key: string;
  data: any;
  timestamp: Date;
  expiresAt: Date;
  operation: string;
  parameters: Record<string, any>;
  accessCount: number;
  lastAccessed: Date;
}

class IntelligentCache {
  private cache: Map<string, CachedResult> = new Map();
  
  generateCacheKey(operation: string, parameters: Record<string, any>): string {
    // Criar chave estável baseada na operação e parâmetros
    const normalized = this.normalizeParameters(parameters);
    return `${operation}:${JSON.stringify(normalized)}`;
  }
  
  shouldCache(operation: string, dataSize: number): boolean {
    const CACHE_RULES = {
      'sales:getHistoricoVendas': { maxSize: 1024 * 100, ttl: 300000 }, // 5min
      'product:getAll': { maxSize: 1024 * 50, ttl: 3600000 }, // 1h
      'subscription:getAll': { maxSize: 1024 * 200, ttl: 180000 }, // 3min
    };
    
    const rule = CACHE_RULES[operation];
    return rule && dataSize <= rule.maxSize;
  }
  
  getOrExecute<T>(
    cacheKey: string,
    operation: () => Promise<T>,
    ttl: number
  ): Promise<T> {
    const cached = this.cache.get(cacheKey);
    
    if (cached && cached.expiresAt > new Date()) {
      cached.accessCount++;
      cached.lastAccessed = new Date();
      return Promise.resolve(cached.data);
    }
    
    return operation().then(result => {
      this.set(cacheKey, result, ttl);
      return result;
    });
  }
  
  invalidateByPattern(pattern: string) {
    // Invalidar cache quando dados podem ter mudado
    // Ex: após cancelar assinatura, invalidar cache de subscription:*
    for (const [key, value] of this.cache.entries()) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
      }
    }
  }
}
```

### 5. Continuidade de Conversação

```typescript
class ConversationContinuity {
  handleFollowUpCommand(
    command: string, 
    context: ConversationContext,
    history: HistoryEntry[]
  ): EnhancedCommand {
    
    const enhanced = { ...command };
    
    // Comandos de continuação
    if (this.isContinuationCommand(command)) {
      return this.handleContinuation(command, context, history);
    }
    
    // Comandos de comparação
    if (this.isComparisonCommand(command)) {
      return this.handleComparison(command, context, history);
    }
    
    // Comandos de refinamento
    if (this.isRefinementCommand(command)) {
      return this.handleRefinement(command, context, history);
    }
    
    return enhanced;
  }
  
  private handleContinuation(
    command: string,
    context: ConversationContext,
    history: HistoryEntry[]
  ): EnhancedCommand {
    const lastQuery = history[history.length - 1];
    
    if (command.includes('mais detalhes') || command.includes('detalhar')) {
      return {
        command: `Mostre detalhes completos de ${this.describeLastQuery(lastQuery)}`,
        inheritedParameters: lastQuery.parsedIntention.parameters,
        verbosity: 'detailed'
      };
    }
    
    if (command.includes('exportar') || command.includes('relatório')) {
      return {
        command: `Gere relatório de ${this.describeLastQuery(lastQuery)}`,
        inheritedParameters: lastQuery.parsedIntention.parameters,
        format: 'report'
      };
    }
    
    return { command };
  }
  
  private handleComparison(
    command: string,
    context: ConversationContext,
    history: HistoryEntry[]
  ): EnhancedCommand {
    if (command.includes('comparar com') || command.includes('vs ')) {
      const lastQuery = history[history.length - 1];
      const comparisonPeriod = this.extractComparisonPeriod(command);
      
      return {
        command: `Compare ${this.describeLastQuery(lastQuery)} com ${comparisonPeriod}`,
        inheritedParameters: lastQuery.parsedIntention.parameters,
        comparisonMode: true,
        comparisonPeriod
      };
    }
    
    return { command };
  }
}
```

### 6. Sistema de Estado de Operações

```typescript
interface PendingOperation {
  operationId: string;
  type: 'single' | 'batch' | 'analysis';
  status: 'queued' | 'running' | 'paused' | 'failed';
  progress: number; // 0-100
  startTime: Date;
  estimatedCompletion?: Date;
  results?: Partial<any>;
  dependencies: string[];
}

class OperationStateManager {
  private pendingOps: Map<string, PendingOperation> = new Map();
  
  pauseOperation(operationId: string): boolean {
    const op = this.pendingOps.get(operationId);
    if (op && op.status === 'running') {
      op.status = 'paused';
      return true;
    }
    return false;
  }
  
  resumeOperation(operationId: string): boolean {
    const op = this.pendingOps.get(operationId);
    if (op && op.status === 'paused') {
      op.status = 'running';
      return true;
    }
    return false;
  }
  
  getOperationStatus(operationId: string): OperationStatus | null {
    const op = this.pendingOps.get(operationId);
    if (!op) return null;
    
    return {
      id: op.operationId,
      status: op.status,
      progress: op.progress,
      timeRemaining: this.calculateTimeRemaining(op)
    };
  }
}
```

## Casos de Uso de Contexto

### 1. Continuidade Simples
```
Usuário: "Mostre vendas de janeiro"
Sistema: [executa e mostra resultados]
Usuário: "E de fevereiro?"
Sistema: [entende que deve mostrar vendas de fevereiro com mesmos filtros]
```

### 2. Refinamento Progressivo
```
Usuário: "Vendas do ano passado"
Sistema: [mostra resumo]
Usuário: "Só produtos digitais"
Sistema: [aplica filtro adicional aos mesmos dados]
Usuário: "Acima de R$ 100"
Sistema: [aplica mais um filtro]
```

### 3. Comparações Contextuais
```
Usuário: "Vendas de dezembro"
Sistema: [mostra dados de dezembro]
Usuário: "Compare com novembro"
Sistema: [mostra comparação dezembro vs novembro]
```

## Persistência de Contexto

### 1. Armazenamento por Sessão
```typescript
interface ContextStorage {
  saveSession(sessionId: string, context: SessionContext): Promise<void>;
  loadSession(sessionId: string): Promise<SessionContext | null>;
  cleanExpiredSessions(): Promise<void>;
}

// Implementação em arquivo
class FileContextStorage implements ContextStorage {
  private storageDir = './context-storage';
  
  async saveSession(sessionId: string, context: SessionContext): Promise<void> {
    const filePath = path.join(this.storageDir, `${sessionId}.json`);
    await fs.writeFile(filePath, JSON.stringify(context, null, 2));
  }
  
  async loadSession(sessionId: string): Promise<SessionContext | null> {
    const filePath = path.join(this.storageDir, `${sessionId}.json`);
    try {
      const data = await fs.readFile(filePath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      return null;
    }
  }
}
```

## Arquivos Impactados

- `nodes/Hotmart/v1/context/` - Novo diretório
  - `SessionManager.ts`
  - `ReferenceResolver.ts`
  - `PreferenceManager.ts`
  - `IntelligentCache.ts`
  - `ConversationContinuity.ts`
  - `ContextStorage.ts`
- `nodes/Hotmart/v1/HotmartV1.node.ts` - Integração com contexto

## Compatibilidade

- ✅ **Memória:** Contexto por sessão MCP
- ✅ **Performance:** Cache inteligente
- ✅ **Escalabilidade:** Limpeza automática de contexto expirado

## Critérios de Aceitação

- [ ] Resolução de referências funcionando ("isso", "mesmo produto")
- [ ] Cache inteligente com TTL apropriado
- [ ] Continuidade de conversação natural
- [ ] Persistência de preferências do usuário
- [ ] Estado de operações longas mantido
- [ ] Limpeza automática de contexto expirado

## Dependências

- RFC-001 (Estrutura Base MCP)
- RFC-002 (Sistema de Processamento de Linguagem Natural)
- RFC-003 (Mapeamento Inteligente de Operações)

## Próximos Passos

Após implementação desta RFC:
1. RFC-005: Interface de Linguagem Natural
2. RFC-006: Sistema de Monitoramento e Analytics

## Testes

### Cenários de Teste de Contexto

```typescript
describe('Sistema de Contexto', () => {
  test('deve resolver referências pronominais', () => {
    const resolver = new ReferenceResolver();
    const context = {
      lastProduct: 'Curso de Marketing',
      referencePoints: new Map([['last_item', { id: 123, name: 'Produto A' }]])
    };
    
    const resolved = resolver.resolvePronouns('Mostre mais detalhes disso', context);
    expect(resolved).toContain('Produto A');
  });
  
  test('deve manter cache entre consultas relacionadas', async () => {
    const cache = new IntelligentCache();
    const key = cache.generateCacheKey('sales:getHistoricoVendas', { month: 1 });
    
    await cache.getOrExecute(key, () => mockApiCall(), 300000);
    const cached = await cache.getOrExecute(key, () => mockApiCall(), 300000);
    
    expect(mockApiCall).toHaveBeenCalledTimes(1); // Segunda chamada usou cache
  });
});
```

## Métricas de Contexto

- **Taxa de Resolução de Referências:** > 90%
- **Eficiência de Cache:** > 70% de cache hits
- **Continuidade de Conversação:** > 95% de comandos de follow-up reconhecidos
- **Tempo de Resposta com Contexto:** < 200ms adicional