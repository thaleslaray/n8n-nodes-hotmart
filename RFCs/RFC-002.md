# RFC-002: Sistema de Processamento de Linguagem Natural

**Status:** Rascunho  
**Autor:** Sistema de Desenvolvimento  
**Data:** Janeiro 2025  
**Versão:** 1.0  

## Resumo

Esta RFC define a implementação do sistema de processamento de linguagem natural para comandos direcionados à Hotmart, permitindo que usuários interajam com a API através de solicitações em português brasileiro sem conhecimento técnico.

## Motivação

Infoprodutores precisam de uma interface intuitiva para:
- Consultar dados de vendas em linguagem natural: "Mostre minhas vendas do último mês"
- Gerenciar assinaturas facilmente: "Cancele todas as assinaturas em atraso"
- Obter insights sem conhecimento técnico: "Qual produto teve melhor performance?"

## Especificação Técnica

### 1. Processador de Intenções

```typescript
interface IntentionProcessor {
  analyzeUserInput(input: string): ParsedIntention;
  extractParameters(input: string, intention: string): Record<string, any>;
  validateCommand(intention: string, parameters: Record<string, any>): ValidationResult;
}

interface ParsedIntention {
  action: 'consultar' | 'gerenciar' | 'analisar' | 'executar';
  resource: 'vendas' | 'assinaturas' | 'produtos' | 'cupons' | 'comissoes';
  operation: string;
  confidence: number;
  parameters: Record<string, any>;
}
```

### 2. Mapeamento de Linguagem Natural

```typescript
const LANGUAGE_MAPPINGS = {
  // Ações comuns em português
  'mostrar': 'get',
  'listar': 'getAll', 
  'obter': 'get',
  'buscar': 'get',
  'cancelar': 'cancel',
  'criar': 'create',
  'excluir': 'delete',
  'reativar': 'reactivate',
  
  // Recursos da Hotmart
  'vendas': 'sales',
  'assinaturas': 'subscriptions',
  'produtos': 'products',
  'cupons': 'coupons',
  'comissões': 'commissions',
  
  // Períodos temporais
  'hoje': () => new Date().toISOString().split('T')[0],
  'ontem': () => getDateDaysAgo(1),
  'última semana': () => getDateDaysAgo(7),
  'último mês': () => getDateDaysAgo(30),
  'este mês': () => getCurrentMonthRange(),
};
```

### 3. Sistema de Validação Contextual

```typescript
class ContextualValidator {
  validateBusinessLogic(intention: ParsedIntention): ValidationResult {
    // Validações específicas de negócio
    if (intention.resource === 'assinaturas' && intention.action === 'cancelar') {
      return this.validateSubscriptionCancellation(intention.parameters);
    }
    
    if (intention.resource === 'vendas' && intention.action === 'consultar') {
      return this.validateSalesQuery(intention.parameters);
    }
    
    return { valid: true };
  }
  
  private validateSubscriptionCancellation(params: any): ValidationResult {
    if (!params.criterio && !params.subscriptionId) {
      return {
        valid: false,
        error: 'Para cancelar assinaturas, especifique um critério ou ID específico'
      };
    }
    return { valid: true };
  }
}
```

## Padrões de Comando Suportados

### 1. Consultas de Vendas
```
"Mostre as vendas de janeiro de 2024"
"Quais foram as vendas do produto X no último mês?"
"Listar todas as vendas com valor acima de R$ 500"
```

### 2. Gestão de Assinaturas
```
"Cancele todas as assinaturas em atraso há mais de 30 dias"
"Mostre assinaturas do produto Y que vencem esta semana"
"Reative a assinatura do cliente joao@email.com"
```

### 3. Análise de Produtos
```
"Qual produto teve melhor performance este mês?"
"Liste os 10 produtos mais vendidos"
"Mostre a receita total por produto"
```

## Implementação

### Fase 1: Parser Básico
```typescript
export class NaturalLanguageProcessor {
  private intentionPatterns: Map<RegExp, IntentionTemplate>;
  
  constructor() {
    this.initializePatterns();
  }
  
  parseCommand(input: string): ParsedIntention {
    const normalizedInput = this.normalizeInput(input);
    
    for (const [pattern, template] of this.intentionPatterns) {
      const match = normalizedInput.match(pattern);
      if (match) {
        return this.buildIntention(template, match);
      }
    }
    
    return this.handleUnknownCommand(input);
  }
  
  private normalizeInput(input: string): string {
    return input
      .toLowerCase()
      .trim()
      .replace(/[áàâãä]/g, 'a')
      .replace(/[éèêë]/g, 'e')
      .replace(/[íìîï]/g, 'i')
      .replace(/[óòôõö]/g, 'o')
      .replace(/[úùûü]/g, 'u')
      .replace(/[ç]/g, 'c');
  }
}
```

### Fase 2: Extração de Parâmetros
```typescript
class ParameterExtractor {
  extractDateRanges(input: string): DateRange | null {
    const datePatterns = [
      /(\d{1,2})\/(\d{1,2})\/(\d{4})/g, // DD/MM/YYYY
      /(janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)\s+de\s+(\d{4})/g,
      /(hoje|ontem|última semana|último mês|este mês)/g
    ];
    
    // Implementar lógica de extração
  }
  
  extractProductReferences(input: string): string[] {
    const productPatterns = [
      /produto\s+([a-zA-Z0-9\s]+)/g,
      /curso\s+([a-zA-Z0-9\s]+)/g,
      /id:?\s*(\d+)/g
    ];
    
    // Implementar lógica de extração
  }
  
  extractMonetaryValues(input: string): number[] {
    const moneyPattern = /R\$\s*(\d+(?:\.\d{3})*(?:,\d{2})?)/g;
    // Implementar conversão para número
  }
}
```

## Contexto e Memória

### Sistema de Contexto de Sessão
```typescript
interface SessionContext {
  userId: string;
  lastQueries: ParsedIntention[];
  preferences: UserPreferences;
  activeFilters: Record<string, any>;
}

class ContextManager {
  private sessions: Map<string, SessionContext>;
  
  maintainContext(userId: string, intention: ParsedIntention): void {
    const context = this.getOrCreateContext(userId);
    context.lastQueries.push(intention);
    
    // Manter apenas últimas 10 queries
    if (context.lastQueries.length > 10) {
      context.lastQueries.shift();
    }
  }
  
  resolveReferences(input: string, context: SessionContext): string {
    // "Mostre mais detalhes" -> usar última query
    // "Do mesmo período" -> usar filtros ativos
    // "Deste produto" -> usar produto da query anterior
  }
}
```

## Tratamento de Ambiguidades

### Sistema de Clarificação
```typescript
class AmbiguityResolver {
  detectAmbiguity(intention: ParsedIntention): AmbiguityType | null {
    if (intention.confidence < 0.7) {
      return 'LOW_CONFIDENCE';
    }
    
    if (this.hasMultipleInterpretations(intention)) {
      return 'MULTIPLE_INTERPRETATIONS';
    }
    
    if (this.hasMissingRequiredParams(intention)) {
      return 'INCOMPLETE_COMMAND';
    }
    
    return null;
  }
  
  generateClarificationPrompt(ambiguity: AmbiguityType, intention: ParsedIntention): string {
    switch (ambiguity) {
      case 'MULTIPLE_INTERPRETATIONS':
        return "Você quer dizer:\n1. Consultar vendas\n2. Analisar performance\n3. Gerar relatório?";
      
      case 'INCOMPLETE_COMMAND':
        return "Para executar este comando, preciso saber: de qual período? qual produto?";
      
      default:
        return "Não entendi completamente. Pode reformular o comando?";
    }
  }
}
```

## Arquivos Impactados

- `nodes/Hotmart/v1/nlp/` - Novo diretório
  - `NaturalLanguageProcessor.ts`
  - `IntentionParser.ts`
  - `ParameterExtractor.ts`
  - `ContextManager.ts`
  - `languageMappings.ts`
- `nodes/Hotmart/v1/HotmartV1.node.ts` - Integração com NLP

## Compatibilidade

- ✅ **MCP:** Funcionalidade central para MCP
- ✅ **n8n:** Não afeta uso tradicional
- ✅ **Português:** Otimizado para pt-BR

## Critérios de Aceitação

- [ ] Parser reconhece comandos básicos em português
- [ ] Extração de parâmetros funcionando
- [ ] Sistema de contexto mantém histórico
- [ ] Tratamento de ambiguidades implementado
- [ ] Taxa de acerto > 85% em comandos comuns
- [ ] Tempo de resposta < 500ms

## Dependências

- RFC-001 (Estrutura Base MCP) deve estar implementada
- Conhecimento dos padrões de API da Hotmart

## Próximos Passos

Após implementação desta RFC:
1. RFC-003: Mapeamento Inteligente de Operações
2. RFC-004: Sistema de Contexto e Memória

## Testes

### Casos de Teste de Linguagem Natural

```typescript
describe('Processamento de Linguagem Natural', () => {
  const nlp = new NaturalLanguageProcessor();
  
  test('deve reconhecer comandos de vendas', () => {
    const resultado = nlp.parseCommand("Mostre as vendas do último mês");
    expect(resultado.resource).toBe('vendas');
    expect(resultado.action).toBe('consultar');
    expect(resultado.parameters.periodo).toBeDefined();
  });
  
  test('deve extrair valores monetários', () => {
    const resultado = nlp.parseCommand("Vendas acima de R$ 1.500,00");
    expect(resultado.parameters.valorMinimo).toBe(1500.00);
  });
});
```

## Referências

- Documentação da API Hotmart
- Padrões de linguagem natural em português brasileiro
- Bibliotecas de NLP para JavaScript/TypeScript