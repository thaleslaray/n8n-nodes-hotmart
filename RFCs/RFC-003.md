# RFC-003: Mapeamento Inteligente de Operações

**Status:** Rascunho  
**Autor:** Sistema de Desenvolvimento  
**Data:** Janeiro 2025  
**Versão:** 1.0  

## Resumo

Esta RFC define o sistema de mapeamento inteligente que traduz comandos de linguagem natural em operações específicas da API Hotmart, considerando contexto de negócio, permissões e otimizações automáticas.

## Motivação

Diferentes comandos podem mapear para a mesma operação, e uma operação pode ser executada de diferentes formas dependendo do contexto:

- "Vendas de janeiro" vs "Faturamento de janeiro" → mesma operação, formatação diferente
- "Cancelar assinatura vencida" → pode usar cancelList ou cancel individual
- "Melhor produto do mês" → requer análise de múltiplas operações

## Especificação Técnica

### 1. Sistema de Mapeamento Contextual

```typescript
interface OperationMapper {
  mapToOperation(intention: ParsedIntention, context: ExecutionContext): MappedOperation;
  optimizeExecution(operations: MappedOperation[]): OptimizedExecutionPlan;
  validatePermissions(operation: MappedOperation, credentials: HotmartCredentials): boolean;
}

interface MappedOperation {
  nodeOperation: string; // Ex: 'sales:getHistoricoVendas'
  parameters: Record<string, any>;
  postProcessing: PostProcessingRule[];
  dependencies: string[];
  priority: number;
}

interface ExecutionContext {
  userIntent: ParsedIntention;
  sessionContext: SessionContext;
  availableOperations: AvailableOperation[];
  userPermissions: Permission[];
}
```

### 2. Regras de Mapeamento por Domínio

```typescript
const MAPPING_RULES = {
  vendas: {
    // Consultas simples
    'consultar vendas': {
      operation: 'sales:getHistoricoVendas',
      requiredParams: ['startDate', 'endDate'],
      optionalParams: ['productId', 'status', 'minValue'],
      postProcessing: ['formatCurrency', 'translateStatus']
    },
    
    // Análises complexas
    'melhor produto': {
      operations: [
        'sales:getHistoricoVendas',
        'sales:getResumoVendas'
      ],
      aggregation: 'calculateBestPerformingProduct',
      postProcessing: ['rankProducts', 'formatInsights']
    },
    
    // Relatórios
    'relatório de vendas': {
      operations: [
        'sales:getHistoricoVendas',
        'sales:getComissoesVendas',
        'sales:getParticipantesVendas'
      ],
      aggregation: 'buildSalesReport',
      output: 'structured_report'
    }
  },
  
  assinaturas: {
    'cancelar assinaturas': {
      // Estratégia otimizada: usar cancelList quando possível
      strategy: 'optimized_batch',
      conditions: {
        'multiple_subscriptions': 'subscription:cancelList',
        'single_subscription': 'subscription:cancel'
      },
      validation: ['checkCancellationPolicy', 'verifyOwnership']
    },
    
    'assinaturas vencendo': {
      operation: 'subscription:getAll',
      filters: ['upcoming_expiration'],
      postProcessing: ['calculateDaysToExpiration', 'prioritizeByValue']
    }
  }
};
```

### 3. Sistema de Otimização de Execução

```typescript
class ExecutionOptimizer {
  optimizeOperationSequence(operations: MappedOperation[]): OptimizedExecutionPlan {
    const plan = new OptimizedExecutionPlan();
    
    // 1. Identificar dependências
    const dependencyGraph = this.buildDependencyGraph(operations);
    
    // 2. Identificar operações que podem ser paralelizadas
    const parallelGroups = this.identifyParallelizable(dependencyGraph);
    
    // 3. Otimizar uso de cache
    const cachedOperations = this.identifyCacheableOperations(operations);
    
    // 4. Batch operations quando possível
    const batchedOperations = this.identifyBatchable(operations);
    
    return plan;
  }
  
  private identifyBatchable(operations: MappedOperation[]): BatchGroup[] {
    const batchGroups: BatchGroup[] = [];
    
    // Agrupar múltiplas consultas de assinatura em uma só
    const subscriptionQueries = operations.filter(op => 
      op.nodeOperation.startsWith('subscription:get')
    );
    
    if (subscriptionQueries.length > 1) {
      batchGroups.push({
        type: 'subscription_batch',
        operations: subscriptionQueries,
        batchOperation: 'subscription:getAll',
        postProcessing: 'splitBatchResponse'
      });
    }
    
    return batchGroups;
  }
}
```

### 4. Agregação e Análise de Dados

```typescript
class DataAggregator {
  aggregateResults(operations: CompletedOperation[], aggregationType: string): AggregatedResult {
    switch (aggregationType) {
      case 'calculateBestPerformingProduct':
        return this.calculateBestPerformingProduct(operations);
      
      case 'buildSalesReport':
        return this.buildComprehensiveSalesReport(operations);
      
      case 'analyzeSubscriptionHealth':
        return this.analyzeSubscriptionHealth(operations);
    }
  }
  
  private calculateBestPerformingProduct(operations: CompletedOperation[]): ProductAnalysis {
    const salesData = this.extractSalesData(operations);
    const products = this.groupByProduct(salesData);
    
    const analysis = products.map(product => ({
      id: product.id,
      name: product.name,
      totalRevenue: product.sales.reduce((sum, sale) => sum + sale.value, 0),
      totalSales: product.sales.length,
      averageValue: product.sales.reduce((sum, sale) => sum + sale.value, 0) / product.sales.length,
      conversionRate: this.calculateConversionRate(product),
      trend: this.calculateTrend(product.sales)
    }));
    
    return {
      products: analysis.sort((a, b) => b.totalRevenue - a.totalRevenue),
      winner: analysis[0],
      insights: this.generateInsights(analysis)
    };
  }
}
```

### 5. Sistema de Validação de Permissões

```typescript
class PermissionValidator {
  validateOperation(operation: MappedOperation, credentials: HotmartCredentials): ValidationResult {
    const required = this.getRequiredPermissions(operation.nodeOperation);
    const available = this.getUserPermissions(credentials);
    
    const missing = required.filter(perm => !available.includes(perm));
    
    if (missing.length > 0) {
      return {
        valid: false,
        error: `Operação requer permissões: ${missing.join(', ')}`,
        suggested: this.suggestAlternatives(operation, available)
      };
    }
    
    return { valid: true };
  }
  
  private getRequiredPermissions(operation: string): Permission[] {
    const PERMISSION_MAP = {
      'sales:getHistoricoVendas': ['sales:read'],
      'sales:solicitarReembolso': ['sales:refund'],
      'subscription:cancel': ['subscription:write'],
      'subscription:cancelList': ['subscription:bulk_write'],
      'coupon:create': ['coupon:write'],
      'coupon:delete': ['coupon:write']
    };
    
    return PERMISSION_MAP[operation] || [];
  }
}
```

## Estratégias de Mapeamento Avançadas

### 1. Mapeamento Multi-Operação
```typescript
// Para "relatório completo de vendas do produto X"
const complexMapping = {
  primary: 'sales:getHistoricoVendas',
  secondary: [
    'sales:getComissoesVendas',
    'sales:getParticipantesVendas',
    'product:getAll' // para buscar detalhes do produto
  ],
  aggregation: 'buildProductSalesReport',
  caching: {
    'product:getAll': '1h', // Cache por 1 hora
    'sales:*': '5m' // Cache de vendas por 5 minutos
  }
};
```

### 2. Mapeamento Condicional
```typescript
// Para "cancelar assinaturas problema"
const conditionalMapping = {
  conditions: [
    {
      if: 'count > 10',
      then: 'subscription:cancelList',
      params: { reason: 'bulk_cancellation' }
    },
    {
      if: 'count <= 10',  
      then: 'subscription:cancel',
      forEach: true,
      params: { reason: 'individual_cancellation' }
    }
  ],
  fallback: 'subscription:getAll', // Se não conseguir determinar
  postProcessing: 'handleCancellationResults'
};
```

### 3. Mapeamento Adaptativo
```typescript
class AdaptiveMapper {
  adaptMapping(intention: ParsedIntention, previousResults: ExecutionResult[]): MappedOperation {
    // Aprender com execuções anteriores
    const userPatterns = this.analyzeUserPatterns(intention.userId);
    const performance = this.analyzePerformance(previousResults);
    
    // Adaptar baseado no histórico
    if (userPatterns.prefersDetailedReports && intention.resource === 'vendas') {
      return this.addDetailedOperations(this.baseMapping(intention));
    }
    
    // Otimizar baseado na performance
    if (performance.slowOperations.includes('sales:getParticipantesVendas')) {
      return this.replaceWithFasterAlternative(this.baseMapping(intention));
    }
    
    return this.baseMapping(intention);
  }
}
```

## Tratamento de Casos Especiais

### 1. Comandos Ambíguos
```typescript
const ambiguityResolver = {
  'vendas': {
    defaultTo: 'sales:getHistoricoVendas',
    whenAmbiguous: [
      { 
        pattern: /receita|faturamento|valor/,
        operation: 'sales:getResumoVendas',
        focus: 'revenue'
      },
      {
        pattern: /transações|quantidade/,
        operation: 'sales:getHistoricoVendas', 
        focus: 'transactions'
      }
    ]
  }
};
```

### 2. Comandos Impossíveis
```typescript
class ImpossibleCommandHandler {
  handleImpossibleCommand(intention: ParsedIntention): CommandResponse {
    const alternatives = this.findAlternatives(intention);
    
    return {
      success: false,
      message: "Esta operação não é possível diretamente, mas posso:",
      alternatives: alternatives.map(alt => ({
        description: alt.description,
        command: alt.suggestedCommand
      }))
    };
  }
}
```

## Arquivos Impactados

- `nodes/Hotmart/v1/mapping/` - Novo diretório
  - `OperationMapper.ts`
  - `ExecutionOptimizer.ts` 
  - `DataAggregator.ts`
  - `PermissionValidator.ts`
  - `mappingRules.ts`
- `nodes/Hotmart/v1/HotmartV1.node.ts` - Integração com mapeamento

## Casos de Uso Complexos

### 1. "Assinaturas que vão cancelar este mês"
```typescript
// Requer análise preditiva
const predictiveCancellation = {
  operations: [
    'subscription:getAll',
    'subscription:getTransactions' // Para analisar padrões de pagamento
  ],
  analysis: 'predictCancellationRisk',
  timeframe: 'current_month',
  threshold: 0.7 // 70% de probabilidade
};
```

### 2. "Produto mais rentável por região"
```typescript
// Requer cruzamento de dados
const regionalAnalysis = {
  operations: [
    'sales:getHistoricoVendas',
    'sales:getParticipantesVendas' // Para obter dados geográficos
  ],
  groupBy: ['product', 'region'],
  calculation: 'profitability_by_region',
  visualization: 'regional_heatmap'
};
```

## Compatibilidade

- ✅ **Operações Existentes:** Usa operações já implementadas
- ✅ **Performance:** Otimizações automáticas
- ✅ **Segurança:** Validação de permissões integrada

## Critérios de Aceitação

- [ ] Mapeamento correto para todas as operações básicas
- [ ] Otimização automática de múltiplas operações
- [ ] Validação de permissões funcionando
- [ ] Agregação de dados para análises complexas
- [ ] Tratamento de casos especiais e ambiguidades
- [ ] Cache inteligente implementado

## Dependências

- RFC-001 (Estrutura Base MCP) 
- RFC-002 (Sistema de Processamento de Linguagem Natural)
- Todas as operações existentes da Hotmart

## Próximos Passos

Após implementação desta RFC:
1. RFC-004: Sistema de Contexto e Memória
2. RFC-005: Interface de Linguagem Natural

## Testes

### Casos de Teste Críticos

```typescript
describe('Mapeamento Inteligente', () => {
  test('deve otimizar múltiplas consultas de assinatura', async () => {
    const mapper = new OperationMapper();
    const operations = [
      { intention: 'assinaturas ativas' },
      { intention: 'assinaturas canceladas' },
      { intention: 'assinaturas vencendo' }
    ];
    
    const optimized = mapper.optimizeExecution(operations);
    expect(optimized.batchedOperations).toHaveLength(1);
    expect(optimized.batchedOperations[0].operation).toBe('subscription:getAll');
  });
});
```

## Métricas de Sucesso

- Taxa de mapeamento correto: > 95%
- Redução no tempo de execução: > 30% para comandos complexos
- Taxa de cache hit: > 60%
- Satisfação do usuário com resultados: > 90%