name: PR - ValidaÃ§Ã£o de Pull Request

on:
  pull_request:
    types: [opened, edited, synchronize]

jobs:
  # Validar informaÃ§Ãµes do PR
  validate-pr:
    name: ğŸ“ Validar PR
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout do cÃ³digo
      uses: actions/checkout@v4
      
    - name: ğŸ·ï¸ Verificar labels
      uses: actions/github-script@v6
      with:
        script: |
          const labels = context.payload.pull_request.labels.map(l => l.name);
          
          // Verificar se tem pelo menos uma label de tipo
          const typeLabels = ['bug', 'enhancement', 'documentation', 'refactor', 'test', 'build'];
          const hasTypeLabel = labels.some(label => typeLabels.includes(label));
          
          if (!hasTypeLabel) {
            core.setFailed('âŒ PR precisa de pelo menos uma label de tipo: ' + typeLabels.join(', '));
          }
          
          // Avisar sobre breaking changes
          if (labels.includes('breaking-change')) {
            core.warning('âš ï¸ Este PR contÃ©m breaking changes! Certifique-se de atualizar a documentaÃ§Ã£o.');
          }
    
    - name: ğŸ“‹ Verificar template do PR
      uses: actions/github-script@v6
      with:
        script: |
          const body = context.payload.pull_request.body || '';
          
          // Verificar se o template foi usado
          const requiredSections = [
            '## ğŸ“‹ DescriÃ§Ã£o',
            '## ğŸ”— Issue Relacionada',
            '## ğŸ’¡ Tipo de MudanÃ§a',
            '## âœ… Checklist'
          ];
          
          const missingSections = requiredSections.filter(section => !body.includes(section));
          
          if (missingSections.length > 0) {
            core.warning('âš ï¸ SeÃ§Ãµes faltando no PR: ' + missingSections.join(', '));
          }
          
          // Verificar se o checklist tem itens marcados
          const checklistItems = (body.match(/\[[ x]\]/g) || []);
          const checkedItems = (body.match(/\[x\]/g) || []);
          
          if (checklistItems.length > 0 && checkedItems.length === 0) {
            core.warning('âš ï¸ Nenhum item do checklist foi marcado!');
          }
          
          console.log(`âœ… Checklist: ${checkedItems.length}/${checklistItems.length} itens marcados`);

  # Verificar commits
  check-commits:
    name: ğŸ“ Verificar Commits
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout do cÃ³digo
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: ğŸ” Validar mensagens de commit
      uses: wagoid/commitlint-github-action@v6
      with:
        configFile: commitlint.config.js
        failOnWarnings: false
        
    - name: ğŸ“Š Analisar tipos de commits
      uses: actions/github-script@v6
      with:
        script: |
          const commits = context.payload.pull_request.commits;
          
          // Buscar commits do PR
          const { data: prCommits } = await github.rest.pulls.listCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number
          });
          
          // Contar tipos de commits
          const commitTypes = {};
          prCommits.forEach(commit => {
            const match = commit.commit.message.match(/^(\w+)(\(.+\))?:/);
            if (match) {
              const type = match[1];
              commitTypes[type] = (commitTypes[type] || 0) + 1;
            }
          });
          
          console.log('ğŸ“Š Tipos de commits no PR:');
          Object.entries(commitTypes).forEach(([type, count]) => {
            console.log(`  - ${type}: ${count}`);
          });

  # Verificar arquivos alterados
  check-files:
    name: ğŸ“ Verificar Arquivos
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout do cÃ³digo
      uses: actions/checkout@v4
      
    - name: ğŸ” Analisar arquivos alterados
      uses: actions/github-script@v6
      with:
        script: |
          const { data: files } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number
          });
          
          // EstatÃ­sticas
          let totalAdditions = 0;
          let totalDeletions = 0;
          const fileTypes = {};
          
          files.forEach(file => {
            totalAdditions += file.additions;
            totalDeletions += file.deletions;
            
            const ext = file.filename.split('.').pop();
            fileTypes[ext] = (fileTypes[ext] || 0) + 1;
            
            // Avisos especÃ­ficos
            if (file.filename.includes('package.json') && !file.filename.includes('package-lock.json')) {
              core.warning('âš ï¸ package.json foi modificado. Certifique-se de atualizar pnpm-lock.yaml');
            }
            
            if (file.filename.endsWith('.test.ts') || file.filename.endsWith('.spec.ts')) {
              console.log(`âœ… Teste incluÃ­do/modificado: ${file.filename}`);
            }
            
            if (file.additions > 500) {
              core.warning(`âš ï¸ Arquivo muito grande: ${file.filename} (+${file.additions} linhas)`);
            }
          });
          
          console.log('\nğŸ“Š Resumo das alteraÃ§Ãµes:');
          console.log(`  - Arquivos: ${files.length}`);
          console.log(`  - AdiÃ§Ãµes: +${totalAdditions}`);
          console.log(`  - DeleÃ§Ãµes: -${totalDeletions}`);
          console.log(`  - Total: ${totalAdditions - totalDeletions}`);
          
          console.log('\nğŸ“ Tipos de arquivo:');
          Object.entries(fileTypes).forEach(([ext, count]) => {
            console.log(`  - .${ext}: ${count}`);
          });
          
          // Verificar se hÃ¡ testes para arquivos modificados
          const srcFiles = files.filter(f => f.filename.includes('/nodes/') && f.filename.endsWith('.ts') && !f.filename.includes('.test.'));
          const testFiles = files.filter(f => f.filename.includes('.test.ts') || f.filename.includes('.spec.ts'));
          
          if (srcFiles.length > 0 && testFiles.length === 0) {
            core.warning('âš ï¸ Arquivos fonte modificados mas nenhum teste foi adicionado/atualizado!');
          }

  # Executar verificaÃ§Ãµes automÃ¡ticas
  auto-checks:
    name: ğŸ¤– VerificaÃ§Ãµes AutomÃ¡ticas
    runs-on: ubuntu-latest
    needs: [validate-pr, check-commits, check-files]
    
    steps:
    - name: ğŸ“¥ Checkout do cÃ³digo
      uses: actions/checkout@v4
      
    - name: ğŸ’¬ Comentar resumo no PR
      uses: actions/github-script@v6
      with:
        script: |
          const comment = `## ğŸ¤– ValidaÃ§Ã£o AutomÃ¡tica do PR
          
          ### âœ… VerificaÃ§Ãµes ConcluÃ­das
          
          - ğŸ“ InformaÃ§Ãµes do PR validadas
          - ğŸ“ Commits verificados
          - ğŸ“ Arquivos analisados
          
          ### ğŸ“‹ PrÃ³ximos Passos
          
          1. Aguarde a conclusÃ£o dos testes de CI
          2. Solicite review de pelo menos 1 maintainer
          3. Responda aos comentÃ¡rios de review
          4. ApÃ³s aprovaÃ§Ã£o, o PR serÃ¡ mergeado
          
          ---
          
          ğŸ’¡ **Dica**: Use \`pnpm test:watch\` localmente para testar durante o desenvolvimento.
          
          <details>
          <summary>ğŸ“š Links Ãšteis</summary>
          
          - [Guia de ContribuiÃ§Ã£o](https://github.com/thaleslaray/n8n-nodes-hotmart/blob/main/CONTRIBUTING.md)
          - [DocumentaÃ§Ã£o](https://github.com/thaleslaray/n8n-nodes-hotmart#readme)
          - [Exemplos](https://github.com/thaleslaray/n8n-nodes-hotmart/tree/main/examples)
          
          </details>`;
          
          // Procurar por comentÃ¡rio existente
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('ğŸ¤– ValidaÃ§Ã£o AutomÃ¡tica do PR')
          );
          
          if (botComment) {
            // Atualizar comentÃ¡rio existente
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            // Criar novo comentÃ¡rio
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }